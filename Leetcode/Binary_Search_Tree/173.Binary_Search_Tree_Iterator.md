
# ðŸŒ³ 173. Binary Search Tree Iterator

## ðŸ“˜ Problem Statement

Design an iterator over the **in-order traversal** of a Binary Search Tree (BST).

The iterator should support:

* **`BSTIterator(TreeNode* root)`** â†’ Initializes the iterator starting at the smallest element.
* **`int next()`** â†’ Returns the next element in the in-order sequence.
* **`bool hasNext()`** â†’ Returns `true` if there are more elements to traverse.

---

## âœ¨ Example

**Input:**

```cpp
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
```

**Output:**

```cpp
[null, 3, 7, true, 9, true, 15, true, 20, false]
```

---

## ðŸš€ Approach: Controlled In-order Traversal with Stack

### *Algorithm*

1. Use a **stack** to simulate recursion for in-order traversal.
2. Initially, push all **left children** of the root onto the stack.
3. `next()` â†’ Pop the top of the stack (smallest available node), then push all left children of its right child.
4. `hasNext()` â†’ Check if the stack is non-empty.

---

### *Time Complexity*

* **Average O(1)** per operation (`next` and `hasNext`) because each node is pushed/popped exactly once.

### *Space Complexity*

* **O(h)** where `h` is the tree height (stack storage).

---

## ðŸ’» Code Implementation

```cpp
class BSTIterator {
private:
    stack<TreeNode*> st;

public:
    BSTIterator(TreeNode* root) {
        pushAll(root);
    }
    
    int next() {
        TreeNode* temp = st.top();
        st.pop();
        pushAll(temp->right);
        return temp->val;
    }
    
    bool hasNext() {
        return !st.empty();
    }
    
private:
    void pushAll(TreeNode* root) {
        while(root != NULL) {
            st.push(root);
            root = root->left;
        }
    }
};
```

---

## ðŸ”§ Constraints

* `1 <= number of nodes <= 10^5`
* `0 <= Node.val <= 10^6`
* Up to `10^5` calls to `next()` and `hasNext()`

---
