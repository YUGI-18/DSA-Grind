
# 🌳 230. Kth Smallest Element in a BST

## 📘 Problem Statement

Given the root of a Binary Search Tree (BST) and an integer `k`, return the **k-th smallest value** (1-indexed) among all the values in the BST.

---

## 🎯 Objective

Leverage the **in-order traversal** property of BSTs (which gives sorted values) to efficiently find the `k`-th smallest element.

---

## ✨ Example

### Example 1:

**Input:**

```cpp
root = [3,1,4,null,2], k = 1
```

**Output:**

```cpp
1
```

---

### Example 2:

**Input:**

```cpp
root = [5,3,6,2,4,null,null,1], k = 3
```

**Output:**

```cpp
3
```

---

## 🚀 Approach: In-order Traversal

### *Algorithm*

1. Perform **in-order traversal** (Left → Node → Right).
2. Keep a counter `cnt` to track how many nodes have been visited.
3. Once `cnt` equals `k`, store the current node's value as the answer.
4. Use recursion and references to pass the counter and result.

---

### *Time Complexity*

* **O(H + k)** where `H` is tree height, because traversal stops once the k-th element is found.
* In worst case: **O(N)**.

### *Space Complexity*

* **O(H)** due to recursion stack, where `H` is tree height.

---

## 💻 Code Implementation

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(root == NULL) return 0;
        int cnt = 0, val = 0;
        small(root, k, cnt, val);
        return val;
    }
    
    void small(TreeNode* root, int k, int& cnt, int& val) {
        if(root == NULL) return;
        
        small(root->left, k, cnt, val);
        
        cnt++;
        if(cnt == k) {
            val = root->val;
            return;
        }
        
        small(root->right, k, cnt, val);
    }
};
```

---

## 🔧 Constraints

* `1 <= k <= n <= 10^4`
* `0 <= Node.val <= 10^4`
* All node values are unique.
* `root` is a valid BST.

---
