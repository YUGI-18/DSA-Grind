
# âœ… 450. Delete Node in a BST

## ğŸ“˜ Problem Summary

Given the root of a BST and a key, delete the node with the given key and return the updated root. Deletion rules:

1. **No child** â€“ remove node.
2. **One child** â€“ replace node with child.
3. **Two children** â€“ replace with max from left subtree or min from right subtree.

---

## ğŸ“¥ Input

* `root = [5,3,6,2,4,null,7]`, `key = 3`

## ğŸ“¤ Output

* `[5,4,6,2,null,null,7]`

---

## ğŸ§  Approach

1. **Search the key** using BST properties.
2. Once the node is found:

   * If **leaf**, return `nullptr`.
   * If **one child**, return the other child.
   * If **two children**:

     * Replace with **in-order predecessor** (max node in left subtree).
     * Attach original right subtree to the rightmost node in left subtree.
3. Use a helper function `help()` to handle deletion logic.
4. Use another helper `rightend()` to find the rightmost node of a subtree.

---

## ğŸ’» Code

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == NULL) return NULL;
        if(root->val == key){
            return help(root);
        } 
        TreeNode *temp = root;
        while(root != NULL){
            if(root->val > key){
                if(root->left != NULL && root->left->val == key){
                    root->left = help(root->left);
                    break;
                }
                else{
                    root = root->left;
                }
            }
            else{
                if(root->right != NULL && root->right->val == key){
                    root->right = help(root->right);
                    break;
                }
                else{
                    root = root->right;
                }
            }
        }
        return temp;
    }

    TreeNode* help(TreeNode* root){
        if(root->left == NULL) return root->right;
        if(root->right == NULL) return root->left;

        TreeNode* rightnode = root->right;
        TreeNode* lastnode = rightend(root->left);
        lastnode->right = rightnode;
        return root->left;
    }

    TreeNode* rightend(TreeNode* root){
        if(root->right == NULL) return root;
        return rightend(root->right);
    }
};
```

---

## ğŸ§ª Dry Run

**Example**: `root = [5,3,6,2,4,null,7]`, `key = 3`

* Node `3` found.
* It has two children: `2` and `4`
* Find rightmost node in left subtree (i.e., `2`)
* Attach `4` (right subtree of `3`) to `2.right`
* Replace `3` with `2`

Final Tree:

```
       5
     /   \
    2     6
     \     \
      4     7
```

---

## â±ï¸ Time Complexity

* Average Case: **O(log N)**
* Worst Case (skewed tree): **O(N)**

## ğŸ“¦ Space Complexity

* **O(H)** â€“ height of tree due to recursion stack

---
