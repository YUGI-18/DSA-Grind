
# ✅ 450. Delete Node in a BST

## 📘 Problem Summary

Given the root of a BST and a key, delete the node with the given key and return the updated root. Deletion rules:

1. **No child** – remove node.
2. **One child** – replace node with child.
3. **Two children** – replace with max from left subtree or min from right subtree.

---

## 📥 Input

* `root = [5,3,6,2,4,null,7]`, `key = 3`

## 📤 Output

* `[5,4,6,2,null,null,7]`

---

## 🧠 Approach

1. **Search the key** using BST properties.
2. Once the node is found:

   * If **leaf**, return `nullptr`.
   * If **one child**, return the other child.
   * If **two children**:

     * Replace with **in-order predecessor** (max node in left subtree).
     * Attach original right subtree to the rightmost node in left subtree.
3. Use a helper function `help()` to handle deletion logic.
4. Use another helper `rightend()` to find the rightmost node of a subtree.

---

## 💻 Code

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == NULL) return NULL;
        if(root->val == key){
            return help(root);
        } 
        TreeNode *temp = root;
        while(root != NULL){
            if(root->val > key){
                if(root->left != NULL && root->left->val == key){
                    root->left = help(root->left);
                    break;
                }
                else{
                    root = root->left;
                }
            }
            else{
                if(root->right != NULL && root->right->val == key){
                    root->right = help(root->right);
                    break;
                }
                else{
                    root = root->right;
                }
            }
        }
        return temp;
    }

    TreeNode* help(TreeNode* root){
        if(root->left == NULL) return root->right;
        if(root->right == NULL) return root->left;

        TreeNode* rightnode = root->right;
        TreeNode* lastnode = rightend(root->left);
        lastnode->right = rightnode;
        return root->left;
    }

    TreeNode* rightend(TreeNode* root){
        if(root->right == NULL) return root;
        return rightend(root->right);
    }
};
```

---

## 🧪 Dry Run

**Example**: `root = [5,3,6,2,4,null,7]`, `key = 3`

* Node `3` found.
* It has two children: `2` and `4`
* Find rightmost node in left subtree (i.e., `2`)
* Attach `4` (right subtree of `3`) to `2.right`
* Replace `3` with `2`

Final Tree:

```
       5
     /   \
    2     6
     \     \
      4     7
```

---

## ⏱️ Time Complexity

* Average Case: **O(log N)**
* Worst Case (skewed tree): **O(N)**

## 📦 Space Complexity

* **O(H)** – height of tree due to recursion stack

---
