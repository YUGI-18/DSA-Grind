
# ðŸŒ³ 653. Two Sum IV â€“ Input is a BST

## ðŸ“˜ Problem Statement

Given the root of a **Binary Search Tree** and an integer `k`, determine if there exist **two distinct elements** in the BST such that their sum equals `k`.

---

## âœ¨ Example

**Example 1:**

```
Input:  root = [5,3,6,2,4,null,7], k = 9
Output: true
```

**Example 2:**

```
Input:  root = [5,3,6,2,4,null,7], k = 28
Output: false
```

---

## ðŸš€ Approach: Two-Pointer on BST Using Iterators

### *Algorithm*

1. Create two **BST iterators**:

   * **Left iterator** â†’ normal in-order traversal (ascending order).
   * **Right iterator** â†’ reverse in-order traversal (descending order).
2. Initialize two pointers:

   * `i` from the smallest value
   * `j` from the largest value
3. While `i < j`:

   * If `i + j == k` â†’ return `true`.
   * If `i + j < k` â†’ move left iterator forward.
   * Else â†’ move right iterator backward.
4. Return `false` if no pair is found.

---

### *Time Complexity*

* **O(N)** worst case, each node is visited at most once.

### *Space Complexity*

* **O(h)** where `h` is the height of the tree (stack storage in iterators).

---

## ðŸ’» Code Implementation

```cpp
class BSTiterator {
    stack<TreeNode*> st;
    bool rev = true;
public:
    BSTiterator(TreeNode* root, bool reverse) {
        rev = reverse;
        pushall(root);
    }
    
    bool hasnext() {
        return !st.empty();
    }
    
    int next() {
        TreeNode* temp = st.top();
        st.pop();
        if (!rev) pushall(temp->right);
        else pushall(temp->left);
        return temp->val;
    }
    
private:
    void pushall(TreeNode* root) {
        while (root != NULL) {
            st.push(root);
            if (rev == true) root = root->right;
            else root = root->left;
        }
    }
};

class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        if (!root) return false;
        BSTiterator l(root, false);
        BSTiterator r(root, true);
        
        int i = l.next();
        int j = r.next();
        
        while (i < j) {
            if (i + j == k) return true;
            else if (i + j < k) i = l.next();
            else j = r.next();
        }
        return false;
    }
};
```

---

## ðŸ”§ Constraints

* `1 <= number of nodes <= 10^4`
* `-10^4 <= Node.val <= 10^4`
* `root` is a valid BST
* `-10^5 <= k <= 10^5`

---
