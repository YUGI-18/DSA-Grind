
# ğŸŒ³ 98. Validate Binary Search Tree

## ğŸ“˜ Problem Statement

Given the root of a binary tree, determine if it is a **valid Binary Search Tree (BST)**.

A valid BST must satisfy:

1. The left subtree contains only nodes with keys **strictly less** than the current nodeâ€™s key.
2. The right subtree contains only nodes with keys **strictly greater** than the current nodeâ€™s key.
3. Both left and right subtrees must themselves be valid BSTs.

---

## âœ¨ Example

### Example 1:

**Input:**

```cpp
root = [2,1,3]
```

**Output:**

```cpp
true
```

---

### Example 2:

**Input:**

```cpp
root = [5,1,4,null,null,3,6]
```

**Output:**

```cpp
false
```

**Explanation:**
The right child of node `5` has value `4`, which violates the BST property.

---

## ğŸš€ Approach: Recursion with Value Bounds

### *Algorithm*

1. Use recursion to traverse the tree.
2. Maintain a valid value range `(min, max)` for each node:

   * All values in the left subtree must be **less than** the current node value.
   * All values in the right subtree must be **greater than** the current node value.
3. Update bounds when moving down the tree:

   * Left child: `(left, root->val)`
   * Right child: `(root->val, right)`
4. If any node violates the bounds, return `false`.

---

### *Time Complexity*

* **O(N)** â€” where `N` is the number of nodes (each node is visited once).

### *Space Complexity*

* **O(H)** â€” recursion stack, where `H` is the height of the tree.

---

## ğŸ’» Code Implementation

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return valid(root, LONG_MIN, LONG_MAX);
    }

    bool valid(TreeNode* root, long left, long right) {
        if(root == NULL) return true;
        if(root->val <= left || root->val >= right) return false;
        return valid(root->left, left, root->val) &&
               valid(root->right, root->val, right);
    }
};
```

---

## ğŸ”§ Constraints

* `1 <= number of nodes <= 10^4`
* `-2^31 <= Node.val <= 2^31 - 1`

---
