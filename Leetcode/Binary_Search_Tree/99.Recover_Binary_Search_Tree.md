
# ðŸŒ³ 99. Recover Binary Search Tree

## ðŸ“˜ Problem Statement

You are given the root of a **Binary Search Tree (BST)** in which exactly **two nodes** have been swapped by mistake.
Recover the BST without changing its structure.

---

## âœ¨ Example

**Example 1:**

```
Input:  root = [1,3,null,null,2]
Output: [3,1,null,null,2]

Explanation:
- 3 cannot be a left child of 1 because 3 > 1.
- Swapping 1 and 3 makes the BST valid.
```

**Example 2:**

```
Input:  root = [3,1,4,null,null,2]
Output: [2,1,4,null,null,3]

Explanation:
- 2 cannot be in the right subtree of 3 because 2 < 3.
- Swapping 2 and 3 makes the BST valid.
```

---

## ðŸš€ Approach: Inorder Traversal (O(1) Extra Space - Morris / Pointer Tracking)

### *Idea*

* Inorder traversal of a BST gives a **sorted sequence**.
* If two nodes are swapped, this sorted order will break in **one or two places**.
* We detect those misplaced nodes while traversing:

  * `first` â†’ the first misplaced node.
  * `middle` â†’ the node right after `first` when first violation occurs.
  * `last` â†’ the node where the second violation occurs (if exists).
* Swap `first` and `last` if there are **two separate violations**.
* Swap `first` and `middle` if there's **only one violation**.

---

### *Time Complexity*

* **O(N)** â†’ each node visited once.

### *Space Complexity*

* **O(1)** â†’ only pointers used (no extra storage except recursion stack).

---

## ðŸ’» Code Implementation

```cpp
class Solution {
private:
    TreeNode* prev;
    TreeNode* first;
    TreeNode* middle;
    TreeNode* last;

    void inorder(TreeNode* root) {
        if (!root) return;

        inorder(root->left);

        // Violation detected
        if (prev != NULL && root->val < prev->val) {
            if (first == NULL) {
                first = prev;
                middle = root;
            } else {
                last = root;
            }
        }
        prev = root;

        inorder(root->right);
    }

public:
    void recoverTree(TreeNode* root) {
        first = middle = last = NULL;
        prev = new TreeNode(INT_MIN);

        inorder(root);

        if (first && last) swap(first->val, last->val);
        else if (first && middle) swap(first->val, middle->val);
    }
};
```

---

## ðŸ”§ Constraints

* `2 <= number of nodes <= 1000`
* `-2^31 <= Node.val <= 2^31 - 1`

---
