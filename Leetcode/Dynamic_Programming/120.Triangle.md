
# **120. Triangle**

---

## **Problem Statement**

You are given a triangle array. Return the minimum path sum from top to bottom.
At each step, you may move to **adjacent numbers** on the row below.
Formally, if you are on index `i` in the current row, you may move to either `i` or `i+1` in the next row.

---

## **Examples**

**Example 1:**

```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation:
   2
  3 4
 6 5 7
4 1 8 3
Minimum path = 2 + 3 + 5 + 1 = 11
```

**Example 2:**

```
Input: triangle = [[-10]]
Output: -10
```

---

## **Approach**

This is a **Dynamic Programming problem**.
We start from the **bottom row** and move upwards, storing the minimum path sum for each cell.

1. **Base Case:** The last row values are copied into the DP table (since those are the ending points).
2. **Transition:** For each element `triangle[i][j]`, we choose the minimum of:

   * Moving **down**: `triangle[i][j] + dp[i+1][j]`
   * Moving **down-right**: `triangle[i][j] + dp[i+1][j+1]`
3. Build the DP table bottom-up until we reach the top.
4. The answer is stored in `dp[0][0]`.

---

## **Code (Tabulation)**

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<vector<int>> dp(n,vector<int>(n,0));
        // Base case: last row
        for(int i=0; i<n ; i++) dp[n-1][i] = triangle[n-1][i];

        // Bottom-up calculation
        for(int i=n-2;i>=0;i--){
            for(int j=i ; j>=0 ; j--){
               int down = triangle[i][j] + dp[i+1][j];
               int diag = triangle[i][j] + dp[i+1][j+1];
               dp[i][j] = min(down,diag);
            }
        }
        return dp[0][0];
    }
};
```

---

## **Code (Space Optimized)**

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();

        vector<int> front(n,0) , cur(n,0);
        // Base case: last row
        for(int i=0; i<n ; i++) front[i] = triangle[n-1][i];

        // Bottom-up calculation
        for(int i=n-2;i>=0;i--){
            for(int j=i ; j>=0 ; j--){
               int down = triangle[i][j] + front[j];
               int diag = triangle[i][j] + front[j+1];
               cur[j] = min(down,diag);
            }
            front = cur;
        }
        return front[0];
    }
};
```

---

## **Complexity Analysis**

* **Time Complexity:** `O(n^2)` â†’ We visit each element once.
* **Space Complexity:**

  * Tabulation: `O(n^2)` (DP table).
  * Space Optimized: `O(n)` (two 1D arrays).

---
