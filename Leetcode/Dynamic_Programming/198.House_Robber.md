
# 198. House Robber

## Problem Description

You are a robber planning to rob houses along a street.

* Each house has some money.
* If you rob **two adjacent houses**, the alarm goes off.
* You must maximize the total money robbed **without robbing adjacent houses**.

Return the maximum money you can rob.

---

## Example

### Input 1:

```
nums = [1,2,3,1]
```

### Output 1:

```
4
```

Explanation: Rob house 1 (1) and house 3 (3) → `1 + 3 = 4`.

---

### Input 2:

```
nums = [2,7,9,3,1]
```

### Output 2:

```
12
```

Explanation: Rob house 1 (2), house 3 (9), and house 5 (1) → `2 + 9 + 1 = 12`.

---

## Code (C++)

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int prev = nums[0], prev2 = 0, n = nums.size();
        int cur = 0;
        
        for(int i=1; i<n; i++){
            int take = nums[i];
            if(i > 1) take += prev2;   // take current + dp[i-2]
            int nottake = prev;        // skip current → dp[i-1]

            cur = max(take, nottake);
            prev2 = prev;
            prev = cur;
        }
        return prev;
    }
};
```

---

## Approach

* This is a **Dynamic Programming** problem:

  * At each house `i`, you have two choices:

    1. **Rob it** → `nums[i] + dp[i-2]`
    2. **Skip it** → `dp[i-1]`
  * Transition: `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`.
* Instead of storing the whole `dp` array, we optimize with two variables:

  * `prev` → dp\[i-1]
  * `prev2` → dp\[i-2]

---

## Complexity

* **Time:** `O(n)` → single pass through houses.
* **Space:** `O(1)` → only using a few variables.

---
