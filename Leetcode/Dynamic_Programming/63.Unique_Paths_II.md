
# **63. Unique Paths II**

---

## **Problem Statement**

You are given an `m x n` integer array `grid`. A robot is initially located at the top-left corner `(0,0)` and wants to move to the bottom-right corner `(m-1, n-1)`.
The robot can only move **right** or **down**.

* A cell with `1` is an obstacle (cannot pass).
* A cell with `0` is free.
* Return the **number of unique paths** from start to end.

---

## **Examples**

### Example 1

**Input:**

```
obstacleGrid = [[0,0,0],
                [0,1,0],
                [0,0,0]]
```

**Output:**

```
2
```

**Explanation:**
There are 2 valid paths:

1. Right → Right → Down → Down
2. Down → Down → Right → Right

---

### Example 2

**Input:**

```
obstacleGrid = [[0,1],
                [0,0]]
```

**Output:**

```
1
```

**Explanation:**
Only one valid path exists since `(0,1)` is blocked.

---

## **Approach**

1. Use **Dynamic Programming (DP)** to build solutions bottom-up.
2. Define `dp[i][j]` as the number of ways to reach cell `(i, j)`.
3. **Base Case:**

   * If `(0,0)` has an obstacle → return `0`.
   * Otherwise, `dp[0][0] = 1`.
4. **Transition Formula:**

   * If `grid[i][j] == 1` → `dp[i][j] = 0`.
   * Otherwise → `dp[i][j] = dp[i-1][j] + dp[i][j-1]` (from top + left).
5. Final answer is `dp[m-1][n-1]`.

---

## **Code (Tabulation DP – No Space Optimization)**

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();

        vector<vector<int>> dp(m, vector<int>(n, -1));

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0; // obstacle
                }
                else if(i == 0 && j == 0) {
                    dp[i][j] = 1; // starting point
                }
                else {
                    int up = 0, left = 0;
                    if(i > 0) up = dp[i-1][j];
                    if(j > 0) left = dp[i][j-1];
                    dp[i][j] = up + left;
                }
            }
        }

        return dp[m-1][n-1];
    }
};
```

---

## **Complexity Analysis**

* **Time Complexity:** `O(m * n)`
  Each cell `(i, j)` is computed once.

* **Space Complexity:** `O(m * n)`
  We maintain a DP table of size `m × n`.

---
