
# **64. Minimum Path Sum**

---

## **Problem Statement**

You are given an `m x n` grid filled with **non-negative numbers**.
Find a path from the **top-left** corner `(0,0)` to the **bottom-right** corner `(m-1, n-1)` that minimizes the sum of all numbers along its path.

You may only move **down** or **right** at any step.

---

## **Examples**

### Example 1

**Input:**

```
grid = [[1,3,1],
        [1,5,1],
        [4,2,1]]
```

**Output:**

```
7
```

**Explanation:**
The path `1 → 3 → 1 → 1 → 1` has the minimum sum of `7`.

---

### Example 2

**Input:**

```
grid = [[1,2,3],
        [4,5,6]]
```

**Output:**

```
12
```

**Explanation:**
The path `1 → 2 → 3 → 6` has the minimum sum of `12`.

---

## **Approach**

1. Use **Dynamic Programming (DP)**.
2. Define `dp[i][j]` = the **minimum path sum** to reach cell `(i, j)`.
3. **Base Case:**

   * At `(0,0)`, the minimum sum is `grid[0][0]`.
4. **Transition Formula:**

   * From **top**: `dp[i-1][j] + grid[i][j]`
   * From **left**: `dp[i][j-1] + grid[i][j]`
   * So:

     ```
     dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
     ```
5. Handle boundary cases (`i==0` or `j==0`) carefully by treating out-of-bound as a large value (`1e9`).
6. Answer is `dp[m-1][n-1]`.

---

## **Code (Tabulation DP – No Space Optimization)**

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 0));

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(i == 0 && j == 0) {
                    dp[i][j] = grid[i][j]; // starting cell
                }
                else {
                    int up = grid[i][j];
                    if(i > 0) up += dp[i-1][j];
                    else up += 1e9;

                    int left = grid[i][j];
                    if(j > 0) left += dp[i][j-1];
                    else left += 1e9;

                    dp[i][j] = min(up, left);
                }
            }
        }

        return dp[n-1][m-1];
    }
};
```

---

## **Code (Space Optimized DP – 1D Array)**

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        vector<int> prev(m, 0);

        for(int i = 0; i < n; i++){
            vector<int> cur(m, 0);
            for(int j = 0; j < m; j++){
                if(i == 0 && j == 0) {
                    cur[j] = grid[i][j];
                }
                else {
                    int up = grid[i][j];
                    if(i > 0) up += prev[j];
                    else up += 1e9;

                    int left = grid[i][j];
                    if(j > 0) left += cur[j-1];
                    else left += 1e9;

                    cur[j] = min(up, left);
                }
            }
            prev = cur;
        }

        return prev[m-1];
    }
};
```

---

## **Complexity Analysis**

* **Time Complexity:** `O(m * n)`
  Each cell is visited once.

* **Space Complexity:**

  * Tabulation: `O(m * n)` (2D DP table).
  * Space Optimized: `O(n)` (1D array).

---
