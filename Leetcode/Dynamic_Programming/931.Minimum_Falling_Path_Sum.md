
# 931. Minimum Falling Path Sum

## Problem Statement

Given an `n x n` array of integers `matrix`, return the **minimum sum of any falling path** through the matrix.

A falling path starts at any element in the first row and chooses the element in the next row that is either:

* directly below,
* diagonally left, or
* diagonally right.

Formally, from `(row, col)`, the next element can be:

* `(row + 1, col - 1)`
* `(row + 1, col)`
* `(row + 1, col + 1)`

---

## Example 1

**Input:**

```
matrix = [[2,1,3],
          [6,5,4],
          [7,8,9]]
```

**Output:**

```
13
```

**Explanation:**
The falling path with minimum sum is:
`2 → 1 → 4 → 6` = `13`.

---

## Example 2

**Input:**

```
matrix = [[-19,57],
          [-40,-5]]
```

**Output:**

```
-59
```

**Explanation:**
The falling path with minimum sum is:
`-19 → -40` = `-59`.

---

## Constraints

* `n == matrix.length == matrix[i].length`
* `1 <= n <= 100`
* `-100 <= matrix[i][j] <= 100`

---

## Approach

We can solve this problem using **Dynamic Programming** in three ways:

### 1. Memoization (Top-Down)

* Start from the last row and move upwards.
* For each cell `(i, j)`, recursively compute the minimum falling path using the three possible moves (`up`, `left diagonal`, `right diagonal`).
* Store results in `dp[i][j]` to avoid recomputation.
* Finally, check the minimum among all paths starting from the last row.

---

### 2. Tabulation (Bottom-Up)

* Use a `dp` table where `dp[i][j]` represents the minimum sum to reach `(i, j)`.
* Initialize the first row with the matrix values.
* For each subsequent row, calculate the minimum by considering values from the previous row (`up`, `left diagonal`, `right diagonal`).
* The answer will be the minimum in the last row.

---

### 3. Space Optimization

* Instead of keeping a full `dp` table, use two 1D arrays: `prev` and `cur`.
* At each row, compute values using only the previous row.
* Reduce space from `O(n^2)` to `O(n)`.

---

## Solutions

### Memoization

```cpp
class Solution {
public:
    int compute(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp) {
        if (j < 0 || j >= matrix.size()) return 1e9;
        if (i == 0) return matrix[i][j];
        if (dp[i][j] != -1) return dp[i][j];

        int left = matrix[i][j] + compute(i - 1, j - 1, matrix, dp);
        int up = matrix[i][j] + compute(i - 1, j, matrix, dp);
        int right = matrix[i][j] + compute(i - 1, j + 1, matrix, dp);

        return dp[i][j] = min(up, min(left, right));
    }

    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        int minval = 1e9;
        for (int i = 0; i < n; i++) {
            minval = min(minval, compute(n - 1, i, matrix, dp));
        }
        return minval;
    }
};
```

---

### Tabulation

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        int minval = 1e9;

        for (int i = 0; i < n; i++) dp[0][i] = matrix[0][i];

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int left = 1e9;
                int up = matrix[i][j];
                int right = 1e9;

                if (j != 0) left = matrix[i][j] + dp[i-1][j-1];
                up += dp[i-1][j];
                if (j < n-1) right = matrix[i][j] + dp[i-1][j+1];

                dp[i][j] = min(up, min(left, right));
            }
        }
        for (int i = 0; i < n; i++) {
            minval = min(minval, dp[n-1][i]);
        }
        return minval;
    }
};
```

---

### Space Optimized

```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        vector<int> prev(n, 0), cur(n, 0);
        int minval = 1e9;

        for (int i = 0; i < n; i++) prev[i] = matrix[0][i];

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int left = 1e9;
                int up = matrix[i][j];
                int right = 1e9;

                if (j != 0) left = matrix[i][j] + prev[j-1];
                up += prev[j];
                if (j < n-1) right = matrix[i][j] + prev[j+1];

                cur[j] = min(up, min(left, right));
            }
            prev = cur;
        }
        for (int i = 0; i < n; i++) {
            minval = min(minval, prev[i]);
        }
        return minval;
    }
};
```

---

## Complexity Analysis

* **Memoization:**

  * Time: `O(n^2)` (Each state `(i,j)` computed once)
  * Space: `O(n^2)` for `dp` + `O(n)` recursion stack

* **Tabulation:**

  * Time: `O(n^2)`
  * Space: `O(n^2)`

* **Space Optimized:**

  * Time: `O(n^2)`
  * Space: `O(n)`

---
