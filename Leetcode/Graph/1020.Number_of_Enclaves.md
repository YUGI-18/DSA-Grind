
# 1020. Number of Enclaves

## Problem Description

You are given an `m x n` binary matrix `grid`, where:

* `0` represents a sea cell
* `1` represents a land cell

A move consists of walking from one land cell to another adjacent (4-directionally) land cell **or** walking off the boundary of the grid.

You need to return the number of land cells in the grid for which it is **impossible** to walk off the boundary of the grid.

### Example 1

**Input:**

```
grid = [[0,0,0,0],
        [1,0,1,0],
        [0,1,1,0],
        [0,0,0,0]]
```

**Output:**

```
3
```

**Explanation:**
There are 3 land cells (`1s`) that are completely enclosed by water and cannot reach the boundary.

---

### Example 2

**Input:**

```
grid = [[0,1,1,0],
        [0,0,1,0],
        [0,0,1,0],
        [0,0,0,0]]
```

**Output:**

```
0
```

**Explanation:**
All land cells are either directly on the boundary or can reach the boundary.

---

## Constraints

* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 500`
* `grid[i][j]` is either `0` or `1`

---

## Approach

We want to count **enclosed land cells** (cannot reach the boundary).

### Key Idea

* Any land cell (`1`) connected to the boundary is **not enclosed**.
* First, run **BFS/DFS** starting from all boundary land cells and mark them as visited.
* Then, count how many land cells (`1`) remain **unvisited** → these are the enclaves.

### Steps

1. Traverse all boundary cells. If a land cell is found, push it into a queue and mark as visited.
2. Perform BFS from these boundary land cells to mark all reachable land cells.
3. After BFS, traverse the grid again and count the land cells (`1`) that were **never visited**.

---

## Code Implementation (C++)

```cpp
class Solution {
public:
    int numEnclaves(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        queue<pair<int,int>> q;
        vector<vector<int>> vis(n,vector<int>(m,0));

        // Step 1: Push all boundary land cells into queue
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(i==0 || j==0 || i==n-1 || j==m-1){
                    if(grid[i][j] == 1){
                        q.push({i,j});
                        vis[i][j] =1;
                    }
                }
            }
        }

        // Step 2: BFS to mark all connected land cells
        int delrow[]={-1,1,0,0};
        int delcol[]={0,0,-1,1};

        while(!q.empty()){
            int row = q.front().first;
            int col = q.front().second;
            q.pop();

            for(int i=0;i<4;i++){
                int nrow = row+delrow[i];
                int ncol = col+delcol[i];

                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && 
                   !vis[nrow][ncol] && grid[nrow][ncol] == 1){
                    vis[nrow][ncol] = 1;
                    q.push({nrow,ncol});
                }
            }
        }

        // Step 3: Count unvisited land cells (enclaves)
        int cnt=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(!vis[i][j] && grid[i][j] == 1){
                    cnt++;
                }
            }
        }
        return cnt;
    }
};
```

---

## Dry Run

### Input:

```
grid = [[0,0,0,0],
        [1,0,1,0],
        [0,1,1,0],
        [0,0,0,0]]
```

* Step 1: Boundary `1s` → only `(1,0)` is pushed.
* Step 2: BFS marks `(1,0)` as visited.
* Step 3: Remaining land cells `(1,2), (2,1), (2,2)` are not visited.
* Count = `3`.

✅ Output = `3`

---

## Complexity Analysis

* **Time Complexity:** `O(m*n)` → Each cell visited at most once.
* **Space Complexity:** `O(m*n)` → Visited matrix + BFS queue.

---
