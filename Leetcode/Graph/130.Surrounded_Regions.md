
# **130. Surrounded Regions**

---

## **Problem Understanding**

We are given an `m x n` board filled with `'X'` and `'O'`.
We need to capture all regions of `'O'` that are **completely surrounded by `'X'`**.

* A region is formed by connecting adjacent `'O'` cells (up, down, left, right).
* If the region **touches the border**, it is **not surrounded** and should not be flipped.
* Otherwise, flip all `'O'` in the surrounded region to `'X'`.

---

## **Input / Output**

### Example 1

**Input:**

```
board = [["X","X","X","X"],
         ["X","O","O","X"],
         ["X","X","O","X"],
         ["X","O","X","X"]]
```

**Output:**

```
[["X","X","X","X"],
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","O","X","X"]]
```

Explanation:

* The middle `'O'` region is captured because it is surrounded.
* The bottom `'O'` is **not captured** because it touches the border.

---

### Example 2

**Input:**

```
board = [["X"]]
```

**Output:**

```
[["X"]]
```

---

## **Approach**

1. **Key Observation**:

   * Any `'O'` connected to the **border** cannot be captured.
   * So, we only need to mark `'O'`s that are reachable from the borders.

2. **Steps**:

   * Traverse all **boundary cells** (first row, last row, first column, last column).
   * If you find an `'O'` on the border, run **DFS** from it to mark all connected `'O'`.
   * After processing, all `'O'` that are **not marked** are surrounded → change them to `'X'`.

3. **Why it works**:

   * Border `'O'` and their connected `'O'`s are safe.
   * Remaining `'O'`s are surrounded and should be captured.

---

## **Dry Run**

Input:

```
board = [["X","X","X","X"],
         ["X","O","O","X"],
         ["X","X","O","X"],
         ["X","O","X","X"]]
```

* Border check: last row → `'O'` at (3,1) → DFS marks it safe.
* Border check: other sides mark nothing extra.
* Now mark all unvisited `'O'` → (1,1), (1,2), (2,2) → convert them to `'X'`.

Final board:

```
[["X","X","X","X"],
 ["X","X","X","X"],
 ["X","X","X","X"],
 ["X","O","X","X"]]
```

---

## **Code (Your Solution)**

```cpp
class Solution {
private:
    void dfs(int row,int col,vector<vector<int>>& vis,vector<vector<char>>& board,int delrow[],int delcol[]){
        vis[row][col] =1;
        int n = board.size();
        int m = board[0].size();
        for(int i=0;i<4;i++){
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && !vis[nrow][ncol] && board[nrow][ncol] == 'O'){
                dfs(nrow,ncol,vis,board,delrow,delcol);
            }
        }
    }
public:
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        int delrow[]={0,0,-1,1};
        int delcol[]={-1,1,0,0};
        vector<vector<int>> vis(n,vector<int>(m,0));
        
        // First and last row
        for(int j=0;j<m;j++){
            if(!vis[0][j] && board[0][j] == 'O'){
                dfs(0,j,vis,board,delrow,delcol);
            }
            if(!vis[n-1][j] && board[n-1][j] == 'O'){
                dfs(n-1,j,vis,board,delrow,delcol);
            }
        }
        
        // First and last column
        for(int i=0;i<n;i++){
            if(!vis[i][0] && board[i][0] == 'O'){
                dfs(i,0,vis,board,delrow,delcol);
            }
            if(!vis[i][m-1] && board[i][m-1] == 'O'){
                dfs(i,m-1,vis,board,delrow,delcol);
            }
        }

        // Flip unvisited 'O' to 'X'
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(!vis[i][j] && board[i][j] == 'O'){
                    board[i][j] = 'X';
                }
            }
        }
    }
};
```

---

## **Complexity Analysis**

* **Time Complexity**:

  * Each cell is visited at most once → **O(m × n)**

* **Space Complexity**:

  * `vis` array + DFS recursion stack → **O(m × n)**

---
