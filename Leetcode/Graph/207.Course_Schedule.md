
# 207. Course Schedule

## Problem Statement

You are given `numCourses` courses labeled `0` to `numCourses - 1`.
You are also given an array **prerequisites** where `prerequisites[i] = [a, b]` means:

* To take course `a`, you must first take course `b`.

Return **true** if you can finish all courses, otherwise return **false**.

---

### Example 1

**Input:**

```
numCourses = 2, prerequisites = [[1,0]]
```

**Output:**

```
true
```

Explanation:
Course `1` depends on course `0`. We can finish courses in the order `[0, 1]`.

---

### Example 2

**Input:**

```
numCourses = 2, prerequisites = [[1,0],[0,1]]
```

**Output:**

```
false
```

Explanation:

* Course `1` requires `0`.
* Course `0` requires `1`.
  This forms a cycle → impossible to finish all courses.

---

## Constraints

* `1 <= numCourses <= 2000`
* `0 <= prerequisites.length <= 5000`
* `prerequisites[i].length == 2`
* `0 <= ai, bi < numCourses`
* All pairs in prerequisites are unique.

---

## Approach 🚀

We need to detect if there’s a **cycle** in the prerequisite graph.

* Model courses as a **directed graph**:

  * Each course is a node.
  * An edge `a → b` means "to take `a`, you must finish `b`".

* Use **Kahn’s Algorithm (Topological Sort via BFS)**:

  1. Compute **indegree** for each node (how many prerequisites it has).
  2. Push all nodes with `indegree = 0` into a queue (courses with no prerequisites).
  3. Repeatedly remove nodes from the queue, reducing indegrees of dependent courses.
  4. If a course’s indegree becomes `0`, push it into the queue.
  5. If we process all `n` courses → possible to finish. Otherwise, cycle exists → return false.

---

## Dry Run 📝

**Input:**

```
numCourses = 2, prerequisites = [[1,0]]
```

Steps:

* Build graph: `1 → 0`.
* Indegrees: `[0,1]`.
* Start queue: `[0]`.
* Process `0`, decrease indegree of `1`. Queue becomes `[1]`.
* Process `1`.

All `2` courses processed → return `true`. ✅

---

## Code (C++) 💻

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        int n = numCourses;
        vector<vector<int>> adj(n);
        
        // Build graph
        for(auto it : prerequisites) {
            adj[it[0]].push_back(it[1]);
        }

        // Compute indegrees
        vector<int> indeg(n, 0);
        for(int i = 0; i < n; i++) {
            for(auto it : adj[i]) {
                indeg[it]++;
            }
        }

        // Push courses with no prerequisites
        queue<int> q;
        for(int i = 0; i < n; i++) {
            if(indeg[i] == 0) q.push(i);
        }

        // BFS for topological sort
        vector<int> topo;
        while(!q.empty()) {
            int node = q.front();
            q.pop();
            topo.push_back(node);

            for(auto it : adj[node]) {
                indeg[it]--;
                if(indeg[it] == 0) q.push(it);
            }
        }

        // If all courses covered, return true
        return topo.size() == n;
    }
};
```

---

## Complexity Analysis 📊

* **Time Complexity:** `O(V + E)`

  * Each node and edge is processed once.
* **Space Complexity:** `O(V + E)`

  * For adjacency list, indegree array, and queue.

---
