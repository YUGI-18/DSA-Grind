
# **542. 01 Matrix**

## **Problem Restatement**

We are given an `m x n` binary matrix `mat` where each cell contains either `0` or `1`.
We need to return a new matrix of the same size where each cell contains the **distance to the nearest `0`**.
The distance is measured in steps, moving only up, down, left, or right.

---

## **Example Walkthrough**

### Example 1:

**Input:**
`mat = [[0,0,0],[0,1,0],[0,0,0]]`

**Output:**
`[[0,0,0],[0,1,0],[0,0,0]]`

➡️ Each `1` is already adjacent to a `0`, so its distance is `1`.

---

### Example 2:

**Input:**
`mat = [[0,0,0],[0,1,0],[1,1,1]]`

**Output:**
`[[0,0,0],[0,1,0],[1,2,1]]`

➡️ Bottom row’s middle cell (`mat[2][1]`) is **2 steps away** from the nearest `0`.

---

## **Approach**

We solve this using **Multi-source BFS**:

1. Initialize a queue with **all cells that already contain `0`**.
2. Mark those cells as visited (`vis`) and set their distance as `0`.
3. Perform BFS:

   * For each cell `(row, col)` in queue, explore its 4 neighbors.
   * If a neighbor is unvisited, mark it visited and assign `dist[neighbor] = step + 1`.
   * Push the neighbor into the queue.
4. Continue until BFS is complete.
5. Return the `dist` matrix.

This ensures that each cell is filled with the **shortest distance to the nearest `0`**.

---

## **Code (C++)**

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n = mat.size();
        int m = mat[0].size();

        vector<vector<int>> vis(n, vector<int>(m, 0));
        vector<vector<int>> dist(n, vector<int>(m, 0));
        queue<pair<pair<int,int>,int>> q;

        // Step 1: Push all 0s into queue
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(mat[i][j] == 0){
                    q.push({{i,j},0});
                    vis[i][j] = 1;
                }
            }
        }

        int delrow[] = {0,0,1,-1};
        int delcol[] = {-1,1,0,0};

        // Step 2: BFS traversal
        while(!q.empty()){
            int row = q.front().first.first;
            int col = q.front().first.second;
            int step = q.front().second;
            dist[row][col] = step;
            q.pop();

            for(int i=0;i<4;i++){
                int nrow = row + delrow[i];
                int ncol = col + delcol[i];
                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && !vis[nrow][ncol]){
                    vis[nrow][ncol] = 1;
                    q.push({{nrow,ncol}, step+1});
                }
            }
        }
        return dist;
    }
};
```

---

## **Dry Run (Example 2)**

`mat = [[0,0,0],[0,1,0],[1,1,1]]`

* Start queue with all `0s`: `(0,0),(0,1),(0,2),(1,0),(1,2)` → step = 0.
* Expand neighbors → fill distances for adjacent `1s`.
* Bottom middle `(2,1)` gets distance `2` (via `(1,1)` → `(0,1)`).

Final `dist = [[0,0,0],[0,1,0],[1,2,1]]`. ✅

---

## **Complexity Analysis**

* **Time Complexity:** `O(m*n)` → each cell is processed once.
* **Space Complexity:** `O(m*n)` → for `vis`, `dist`, and queue.

---
