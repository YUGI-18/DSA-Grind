
# 547. Number of Provinces

---

## ✅ Problem Explanation

We are given an `n x n` adjacency matrix `isConnected` representing connections between cities.

* If `isConnected[i][j] = 1`, then city `i` and city `j` are directly connected.
* A **province** is a group of cities that are either directly or indirectly connected.

We need to return the **total number of provinces**.

---

## 🔹 Example Walkthrough

### Example 1

**Input:**
`isConnected = [[1,1,0],[1,1,0],[0,0,1]]`

* Cities 0 and 1 are connected → one province.
* City 2 is isolated → another province.

**Output:**
`2`

---

### Example 2

**Input:**
`isConnected = [[1,0,0],[0,1,0],[0,0,1]]`

* No cities are connected except themselves.
* So there are **3 separate provinces**.

**Output:**
`3`

---

## 💡 Approach

1. Convert the adjacency matrix `isConnected` into an **adjacency list**.
2. Use **DFS** to explore all connected cities.
3. Maintain a visited array `vis[]` to mark visited cities.
4. For each unvisited city, increment the province count and run DFS from that city.
5. The total count will be the number of provinces.

---

## 🧩 Dry Run (Example 1)

Input: `isConnected = [[1,1,0],[1,1,0],[0,0,1]]`

* Convert to adjacency list:

  ```
  0 → [1]  
  1 → [0]  
  2 → []  
  ```

* Start with city `0` → DFS visits {0,1}. → Province count = 1.

* Next city `1` already visited → skip.

* Next city `2` not visited → DFS visits {2}. → Province count = 2.

Final Answer = `2`

---


## 📝 Code Implementation (Your Code, As-Is)

```cpp
class Solution {
private:
    void dfs(int node,vector<vector<int>>& adj,vector<int>& vis){
        vis[node]=1;
        for(auto it: adj[node]){
            if(!vis[it]){
                dfs(it,adj,vis);
            }
        }
    }

public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<vector<int>> adj(n);
        for(int i=0; i<n;i++){
            for(int j=0;j<n;j++){
                if(isConnected[i][j] == 1 && i!=j){
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        vector<int> vis(n,0);
        int cnt=0;
        for(int i=0;i<n;i++){
            if(!vis[i]){
                cnt++;
                dfs(i,adj,vis);
            }
        }
        return cnt;
    }
};
```

---

## ⏱️ Complexity Analysis

* **Time Complexity:** `O(n^2)` → Building adjacency list + DFS traversal.
* **Space Complexity:** `O(n + E)` for adjacency list + `O(n)` visited array.

---