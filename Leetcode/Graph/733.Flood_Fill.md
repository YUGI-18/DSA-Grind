
# 733. Flood Fill

## Problem Statement

You are given an image represented by an `m x n` grid of integers `image`, where `image[i][j]` represents the pixel value of the image. You are also given three integers `sr`, `sc`, and `color`. Your task is to perform a flood fill on the image starting from the pixel `image[sr][sc]`.

### Flood Fill Process:

1. Begin with the starting pixel and change its color to `color`.
2. Perform the same process for each pixel that is directly adjacent (sharing a side) and has the same color as the starting pixel.
3. Continue until no more adjacent pixels of the original color remain.
4. Return the modified image after performing the flood fill.

---

## Examples

### Example 1

**Input:**

```
image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2
```

**Output:**

```
[[2,2,2],[2,2,0],[2,0,1]]
```

**Explanation:**
Starting from `(1,1)`, all connected pixels with the same original color `1` are changed to `2`.

---

### Example 2

**Input:**

```
image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0
```

**Output:**

```
[[0,0,0],[0,0,0]]
```

**Explanation:**
The starting pixel already has the same target color, so no changes are made.

---

## Constraints

* `m == image.length`
* `n == image[i].length`
* `1 <= m, n <= 50`
* `0 <= image[i][j], color < 2^16`
* `0 <= sr < m`
* `0 <= sc < n`

---

## Code (C++)

```cpp
class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int n = image.size();
        int m = image[0].size();
        vector<vector<int>> vis(n,vector<int>(m,0));
        queue<pair<int,int>>q;
        q.push({sr,sc});
        vis[sr][sc] = 1;
        int pix = image[sr][sc];
        image[sr][sc] = color;

        int drow[4] = {0,0,-1,1};
        int dcol[4] = {-1,1,0,0}; 
        while(!q.empty()){
            int row = q.front().first;
            int col = q.front().second;
            q.pop();
            for(int k =0 ;k<4 ;k++){
                int nrow = row + drow[k];
                int ncol = col + dcol[k];
                if(nrow >=0 && nrow <n && ncol>=0 && ncol <m && image[nrow][ncol] == pix && !vis[nrow][ncol]){
                    image[nrow][ncol] = color;
                    vis[nrow][ncol] = 1;
                    q.push({nrow,ncol});
                }
            }
        }
        return image; 
    }
};
```

---

## Input / Output Walkthrough

### Example 1 Dry Run

* **Input:** `image = [[1,1,1],[1,1,0],[1,0,1]]`, `sr = 1`, `sc = 1`, `color = 2`
* Starting pixel = `(1,1)` → value = `1`
* Change `(1,1)` → `2`
* Adjacent same-color pixels: `(0,1), (1,0), (1,2), (2,1)`
* BFS fills all connected `1`s with `2`.
* **Final Output:** `[[2,2,2],[2,2,0],[2,0,1]]`

---

## Approach

1. **BFS Traversal**

   * Use a queue to explore neighbors.
   * Start from `(sr, sc)` and change it to the new color.
   * For each pixel, check its 4 directions.
   * If a neighbor has the same original color and is not visited, update it and push it into the queue.

2. **Why BFS?**

   * Ensures level-wise exploration.
   * Prevents infinite recursion compared to DFS (though DFS also works).

---

## Complexity Analysis

* **Time Complexity:** `O(m * n)`

  * In the worst case, all pixels are visited once.
* **Space Complexity:** `O(m * n)`

  * For the visited matrix + queue storage.

---
