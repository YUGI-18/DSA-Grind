
# 785. Is Graph Bipartite?

## Problem Statement

You are given an undirected graph with `n` nodes, where each node is numbered between `0` and `n - 1`.
The graph is represented as a 2D array `graph`, where `graph[u]` is an array of nodes adjacent to node `u`.

A graph is **bipartite** if the nodes can be partitioned into two independent sets **A** and **B** such that every edge connects a node in set A to a node in set B.

Return **true** if and only if the graph is bipartite.

---

## Example 1:

**Input:**

```
graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
```

**Output:**

```
false
```

**Explanation:**
There is no way to partition the nodes into two independent sets.

---

## Example 2:

**Input:**

```
graph = [[1,3],[0,2],[1,3],[0,2]]
```

**Output:**

```
true
```

**Explanation:**
We can partition the nodes into two sets: `{0, 2}` and `{1, 3}`.

---

## Constraints:

* `graph.length == n`
* `1 <= n <= 100`
* `0 <= graph[u].length < n`
* `0 <= graph[u][i] <= n - 1`
* `graph[u]` does not contain `u`
* All the values of `graph[u]` are unique
* If `graph[u]` contains `v`, then `graph[v]` contains `u`

---

## Approach 🚀

* Use **BFS coloring** to check if the graph is bipartite.
* Maintain a `color` array initialized to `-1`.
* For each unvisited node:

  * Assign it a color (`0`).
  * Traverse its neighbors:

    * If uncolored, assign the **opposite color** and continue.
    * If already colored and the same as the current node → **not bipartite**.
* If no conflicts arise → the graph is bipartite.

---

## Dry Run 📝

For `graph = [[1,3],[0,2],[1,3],[0,2]]`

* Start with node `0` → color `0`.
* Neighbors:

  * `1` → assign color `1`.
  * `3` → assign color `1`.
* Node `1` → neighbor `2` → assign color `0`.
* Node `2` → neighbor `3` already has opposite color.
  ✅ No conflicts → Graph is bipartite.

---

## Code (C++)

```cpp
class Solution {
private:
    bool check(int start,int n,vector<vector<int>>& graph,int color[]){
        queue<int> q;
        q.push(start);
        color[start] = 0;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            for(auto it : graph[node]){
                if(color[it] == -1){
                    color[it] = !color[node];
                    q.push(it);
                }
                else if(color[it] == color[node]){
                    return false;
                }
            }
        }
        return true;
    }

public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        int color[n]; 
        for(int i=0;i<n;i++) color[i] = -1;
        for(int i=0;i<n;i++){
            if(color[i] == -1){
                if(!check(i,n,graph,color)){
                    return false;
                }
            }
        }
        return true;
    }
};
```

---

## Complexity Analysis

* **Time Complexity:** `O(V + E)`

  * Each node and edge is visited once in BFS.
* **Space Complexity:** `O(V)`

  * For color array and BFS queue.

---
