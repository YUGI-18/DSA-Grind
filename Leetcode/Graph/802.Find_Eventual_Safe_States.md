
# 802. Find Eventual Safe States

## Problem Statement

We are given a directed graph of `n` nodes (labeled `0` to `n-1`). A node is considered:

* **Terminal node**: If it has no outgoing edges.
* **Safe node**: If **all paths** starting from it eventually lead to a terminal node (or another safe node).

We need to return all the **safe nodes** in ascending order.

### Example 1

**Input:**

```
graph = [[1,2],[2,3],[5],[0],[5],[],[]]
```

**Output:**

```
[2,4,5,6]
```

Explanation:

* Nodes `5` and `6` are terminal nodes.
* From nodes `2` and `4`, every path eventually reaches `5` or `6`.

---

### Example 2

**Input:**

```
graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
```

**Output:**

```
[4]
```

Explanation:

* Only node `4` is terminal.
* All paths starting from `4` end at itself (safe).

---

## Constraints

* `n == graph.length`
* `1 <= n <= 10^4`
* `0 <= graph[i].length <= n`
* `0 <= graph[i][j] <= n - 1`
* Graph may contain self-loops.
* Number of edges ∈ `[1, 4 * 10^4]`.

---

## Approach 🚀

We use **DFS with cycle detection**:

1. Maintain three arrays:

   * `vis[i]`: Marks if a node has been visited.
   * `path[i]`: Marks if a node is part of the current DFS recursion stack.
   * `check[i]`: Marks if a node is safe (`1`) or not (`0`).

2. Perform DFS for each unvisited node:

   * If we encounter a **back edge (cycle)** → node is **unsafe**.
   * Otherwise, if recursion completes without cycles → node is **safe**.

3. After DFS traversal, collect all nodes where `check[i] == 1`.

This works because:

* Safe nodes are those **not part of any cycle**.
* Any node that eventually leads to a cycle is unsafe.

---

## Dry Run 📝

**Input:**

```
graph = [[1,2],[2,3],[5],[0],[5],[],[]]
```

Step-by-step:

* Start with `0`: Path → `0 -> 1 -> 2 -> 5` (safe).
* Node `3` points back to `0` → cycle detected.
* `4 -> 5` (safe).
* `5` and `6` are terminal → safe.

Safe nodes: `[2,4,5,6]`. ✅

---

## Code (C++) 💻

```cpp
class Solution {
private:
    bool dfscheck(int node, vector<vector<int>>& graph, vector<int>& vis,
                  vector<int>& path, vector<int>& check) {
        vis[node] = 1;
        path[node] = 1;
        check[node] = 0;

        for(auto it : graph[node]) {
            if(!vis[it]) {
                if(dfscheck(it, graph, vis, path, check)) {
                    check[node] = 0;
                    return true;
                }
            }
            else if(path[it]) {
                check[node] = 0;
                return true;
            }
        }

        check[node] = 1;
        path[node] = 0;
        return false;
    }

public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> vis(n, 0), path(n, 0), check(n, 0), safe;

        for(int i = 0; i < n; i++) {
            if(!vis[i]) {
                dfscheck(i, graph, vis, path, check);
            }
        }

        for(int i = 0; i < n; i++) {
            if(check[i] == 1) safe.push_back(i);
        }
        return safe;
    }
};
```

---

## Complexity Analysis 📊

* **Time Complexity:** `O(V + E)`

  * Each node and edge is processed once in DFS.
* **Space Complexity:** `O(V)`

  * For `vis`, `path`, `check`, and recursion stack.

---
