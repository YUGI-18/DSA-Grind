
# 994. Rotting Oranges

## Problem Description

You are given an `m x n` grid where each cell can have one of three values:

* `0` → an empty cell
* `1` → a fresh orange
* `2` → a rotten orange

Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.

Return the **minimum number of minutes** that must elapse until no cell has a fresh orange. If this is impossible, return `-1`.

---

## Examples

### Example 1

**Input:**

```cpp
grid = [[2,1,1],
        [1,1,0],
        [0,1,1]]
```

**Output:**

```
4
```

---

### Example 2

**Input:**

```cpp
grid = [[2,1,1],
        [0,1,1],
        [1,0,1]]
```

**Output:**

```
-1
```

**Explanation:** The orange at the bottom left corner never rots since rotting only happens 4-directionally.

---

### Example 3

**Input:**

```cpp
grid = [[0,2]]
```

**Output:**

```
0
```

**Explanation:** No fresh oranges exist, so the answer is 0.

---

## Constraints

* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 10`
* `grid[i][j]` is `0`, `1`, or `2`.

---

## Approach

We use **Breadth-First Search (BFS)** because rotting spreads level by level (minute by minute).

### Steps:

1. **Initialization:**

   * Use a queue to perform BFS.
   * Push all **rotten oranges (2)** into the queue with time = `0`.
   * Maintain a `vis` matrix to track visited/rotted cells.

2. **BFS Traversal:**

   * For each rotten orange, check its 4 neighbors (up, down, left, right).
   * If a neighbor is a fresh orange (`1`), mark it rotten, push it into the queue with `time+1`.

3. **Track Time:**

   * Keep updating the maximum time taken while processing nodes.

4. **Final Check:**

   * After BFS, scan the grid. If any fresh orange (`1`) is still left, return `-1`.
   * Otherwise, return the maximum time.

---

## Code (C++)

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        queue<pair<pair<int,int>,int>> q;
        vector<vector<int>> vis(n,vector<int>(m,0));

        // Push all initially rotten oranges
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j] == 2){
                    q.push({{i,j},0});
                    vis[i][j] = 2;
                }
            }
        }

        int drow[4] = {0,1,0,-1};
        int dcol[4] = {-1,0,1,0};
        int time = 0;

        // BFS traversal
        while(!q.empty()){
            int row = q.front().first.first;
            int col = q.front().first.second;
            int t = q.front().second;
            time = max(time, t);
            q.pop();

            for(int k=0;k<4;k++){
                int nrow = row + drow[k];
                int ncol = col + dcol[k];
                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m 
                   && grid[nrow][ncol] == 1 && vis[nrow][ncol] != 2){
                    grid[nrow][ncol] = 2;
                    vis[nrow][ncol] = 2;
                    q.push({{nrow,ncol}, t+1});
                }
            }
        }

        // Check for any fresh orange left
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j] == 1){
                    return -1;
                }
            }
        }
        
        return time;
    }
};
```

---

## Complexity Analysis

* **Time Complexity:** `O(m * n)`

  * Each cell is processed at most once in BFS.

* **Space Complexity:** `O(m * n)`

  * For the queue and visited matrix.

---
