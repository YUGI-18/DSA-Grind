
# 1091. Shortest Path in Binary Matrix

## Problem Statement

You are given an `n x n` binary matrix `grid`. Return the **length of the shortest clear path** from **top-left** `(0,0)` to **bottom-right** `(n-1,n-1)`.

### Rules:

* A path is **clear** if all visited cells contain `0`.
* Cells are **8-directionally connected** (up, down, left, right, and all 4 diagonals).
* The length of a clear path is the number of visited cells.
* If no such path exists, return `-1`.

---

### Example 1

**Input:**

```
grid = [[0,1],
        [1,0]]
```

**Output:**

```
2
```

**Explanation:**
Path = `(0,0) → (1,1)`.

---

### Example 2

**Input:**

```
grid = [[0,0,0],
        [1,1,0],
        [1,1,0]]
```

**Output:**

```
4
```

**Explanation:**
Path = `(0,0) → (0,1) → (0,2) → (1,2) → (2,2)`

---

### Example 3

**Input:**

```
grid = [[1,0,0],
        [1,1,0],
        [1,1,0]]
```

**Output:**

```
-1
```

**Explanation:**
Start `(0,0)` is blocked, so no path exists.

---

## Constraints

* `n == grid.length`
* `n == grid[i].length`
* `1 <= n <= 100`
* `grid[i][j]` is either `0` or `1`

---

## Approach 🚀

This is a **shortest path problem in a grid** with **8-directional moves**.
The best approach is **BFS (Breadth First Search)** since it naturally finds the shortest path in an unweighted graph.

**Steps:**

1. Check if `grid[0][0]` is blocked (`1`). If so, return `-1`.
2. If the grid is **1x1** and `grid[0][0] == 0`, return `1`.
3. Use a **queue** to perform BFS, storing `(distance, (row, col))`.
4. Maintain a `dist` matrix initialized to `∞`. Set `dist[0][0] = 0`.
5. For each popped cell, check all **8 directions**.
6. If the neighbor is valid (inside grid, value `0`, not visited with a shorter distance), push into the queue.
7. If `(n-1, n-1)` is reached, return the distance + 1.
8. If BFS completes without reaching the end, return `-1`.

---

## Dry Run 📝

**Input:**

```
grid = [[0,0,0],
        [1,1,0],
        [1,1,0]]
```

Steps:

* Start at `(0,0)` → push with distance `0`.
* Neighbors → `(0,1)` → `(0,2)` → `(1,2)` → `(2,2)`.
* Reached end with distance = 3, so path length = **4**. ✅

---

## Code (C++) 💻

```cpp
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();

        // if start blocked
        if(grid[0][0] != 0 && n != 1 && m != 1) return -1;
        // if only one cell and it's open
        if(grid[0][0] == 0 && n == 1 && m == 1) return 1;

        vector<vector<int>> dist(n, vector<int>(m, 1e9));
        dist[0][0] = 0;

        queue<pair<int,pair<int,int>>> q;
        q.push({0, {0,0}});

        vector<int> delr = {0,-1,0,1,-1,-1,1,1};
        vector<int> delc = {-1,0,1,0,1,-1,1,-1};

        while(!q.empty()) {
            int dis = q.front().first;
            int row = q.front().second.first;
            int col = q.front().second.second;
            q.pop();

            for(int i = 0; i < 8; i++) {
                int newr = row + delr[i];
                int newc = col + delc[i];

                if(newr >= 0 && newr < n && newc >= 0 && newc < m &&
                   grid[newr][newc] == 0 && dis + 1 < dist[newr][newc]) {
                    
                    dist[newr][newc] = dis + 1;
                    q.push({dis+1, {newr, newc}});

                    if(newr == n-1 && newc == m-1) 
                        return dis + 2; // include last cell
                }
            }
        }
        return -1;
    }
};
```

---

## Complexity Analysis 📊

* **Time Complexity:** `O(n^2)`

  * Each cell is processed at most once in BFS.
* **Space Complexity:** `O(n^2)`

  * For `dist` matrix + queue.

---