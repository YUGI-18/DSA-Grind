
# 127. Word Ladder

## Problem Statement

A **transformation sequence** from `beginWord` to `endWord` using words from `wordList` is a sequence:

```
beginWord -> s1 -> s2 -> ... -> sk
```

such that:

1. Every adjacent pair of words differs by **exactly one letter**.
2. Every word `si` (for `1 <= i <= k`) is in `wordList`.
3. `sk == endWord`.

Return the **length** of the shortest transformation sequence from `beginWord` to `endWord`.
If no such sequence exists, return `0`.

---

### Example 1

**Input:**

```
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
```

**Output:**

```
5
```

**Explanation:**
One shortest sequence is:

```
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
```

Length = **5**.

---

### Example 2

**Input:**

```
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
```

**Output:**

```
0
```

**Explanation:**
`endWord = "cog"` is **not in the wordList**, so no valid transformation exists.

---

## Constraints

* `1 <= beginWord.length <= 10`
* `endWord.length == beginWord.length`
* `1 <= wordList.length <= 5000`
* All words in `wordList` have the same length.
* All words consist of lowercase English letters.
* `beginWord != endWord`
* All words in `wordList` are unique.

---

## Approach 🚀

We need the **shortest path** in a transformation graph, where:

* Each **word** is a node.
* There is an edge between two words if they differ by exactly **one letter**.

This is a classic **BFS shortest path problem**.

**Steps:**

1. Insert all words into an **unordered\_set** for O(1) lookup.
2. Start BFS from `beginWord` with step = 1.
3. For each word, try replacing each character with `'a' to 'z'` → generate new possible words.
4. If the new word exists in the set:

   * Push into queue with `step + 1`.
   * Remove from set (to avoid revisiting).
5. If `endWord` is reached, return steps.
6. If BFS ends without finding `endWord`, return `0`.

---

## Dry Run 📝

**Input:**

```
beginWord = "hit", endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
```

Steps:

* Start: queue = `[("hit",1)]`.
* From `"hit"` → generate `"hot"` → push `(hot,2)`.
* From `"hot"` → generate `"dot","lot"` → push `(dot,3),(lot,3)`.
* From `"dot"` → generate `"dog"` → push `(dog,4)`.
* From `"dog"` → generate `"cog"` → found → return **5**. ✅

---


## Code (C++) 💻

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        queue<pair<string,int>> q;
        unordered_set<string> st(wordList.begin(), wordList.end());

        q.push({beginWord, 1});
        st.erase(beginWord);

        while(!q.empty()) {
            string org = q.front().first;
            int step = q.front().second;
            q.pop();

            if(org == endWord) return step;

            for(int i = 0; i < org.size(); i++) {
                char cur = org[i];
                for(char c = 'a'; c <= 'z'; c++) {
                    org[i] = c;
                    if(st.find(org) != st.end()) {
                        q.push({org, step + 1});
                        st.erase(org);
                    }
                }
                org[i] = cur; // restore original char
            }
        }
        return 0;
    }
};
```

---

## Complexity Analysis 📊

* **Time Complexity:** `O(N * L * 26)`

  * `N = number of words`, `L = word length`.
  * For each word, try replacing each character with 26 letters.
* **Space Complexity:** `O(N)`

  * For queue + set.

---