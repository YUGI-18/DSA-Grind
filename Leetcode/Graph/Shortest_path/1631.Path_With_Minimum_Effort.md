
# 1631. Path With Minimum Effort

## Problem

You are given a 2D grid `heights` where `heights[row][col]` represents the height of the cell at `(row, col)`.

You start from `(0, 0)` and want to reach `(rows-1, cols-1)`.

* You can move **up, down, left, right**.
* The **effort** of a path is the **maximum absolute difference** in heights between consecutive cells.
* Find the **minimum effort** required to reach the destination.

---

## Example

**Input:**

```
heights = [[1,2,2],
           [3,8,2],
           [5,3,5]]
```

**Output:**

```
2
```

**Explanation:**

* Path `[1,3,5,3,5]` has maximum difference = 2 → ✅ Optimal.
* Path `[1,2,2,2,5]` has maximum difference = 3 → ❌

---

## Approach

We use **Dijkstra’s Algorithm** on the grid:

1. Each cell `(i, j)` is treated as a graph node.
2. Instead of minimizing total distance, we minimize the **maximum effort** along the path.
3. Maintain a `dist` matrix where `dist[r][c]` = minimum effort required to reach `(r, c)`.
4. Use a **min-heap (priority queue)** to always expand the cell with the least effort.
5. Stop early when we reach the bottom-right cell.

---

## Dry Run

For `heights = [[1,2,3],[3,8,4],[5,3,5]]`:

* Start at `(0,0)` with effort `0`.
* Move to `(0,1)` → diff = `1` → effort = `1`.
* Move to `(0,2)` → diff = `1` → effort still `1`.
* Move to `(1,2)` → diff = `1` → effort still `1`.
* Move to `(2,2)` → diff = `1` → ✅ Reached with min effort `1`.

---

## Code

```cpp
class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int n = heights.size();
        int m = heights[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 1e9));
        
        // Min-heap {effort, {row, col}}
        priority_queue<pair<int, pair<int,int>>, 
                       vector<pair<int, pair<int,int>>>, 
                       greater<pair<int, pair<int,int>>>> pq;
        
        pq.push({0, {0, 0}});
        dist[0][0] = 0;

        vector<int> delr = {-1, 0, 1, 0};
        vector<int> delc = {0, -1, 0, 1};

        while (!pq.empty()) {
            int diff = pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second;
            pq.pop();

            if (row == n-1 && col == m-1) return diff;  // reached destination

            for (int i = 0; i < 4; i++) {
                int newr = row + delr[i];
                int newc = col + delc[i];
                if (newr >= 0 && newr < n && newc >= 0 && newc < m) {
                    int newdiff = max(diff, abs(heights[row][col] - heights[newr][newc])); 
                    if (newdiff < dist[newr][newc]) {
                        dist[newr][newc] = newdiff;
                        pq.push({newdiff, {newr, newc}});
                    }
                }
            }
        }
        return 0;
    }
};
```

---

## Complexity

* **Time Complexity:** `O(N * M * log(N * M))`

  * Each cell `(r, c)` is processed once, with heap operations.
* **Space Complexity:** `O(N * M)`

  * For `dist` matrix and heap storage.

---
