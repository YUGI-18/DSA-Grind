
# 1976. Number of Ways to Arrive at Destination

## Problem Description

We are given a city with **n intersections** (0 to n-1) connected by bidirectional roads. Each road has a travel time.
We need to calculate **the number of distinct ways** to travel from intersection `0` to intersection `n-1` in the **shortest time possible**.
Since the answer can be very large, return it modulo `1e9+7`.

---

## Example

### Input 1:

```
n = 7
roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
```

### Output 1:

```
4
```

Explanation:
Shortest time from 0 → 6 is `7 minutes`.
The four shortest paths are:

* 0 → 6
* 0 → 4 → 6
* 0 → 1 → 2 → 5 → 6
* 0 → 1 → 3 → 5 → 6

---

### Input 2:

```
n = 2
roads = [[1,0,10]]
```

### Output 2:

```
1
```

Explanation:
Only one path `0 → 1` with time `10`.

---

## Code (C++)

```cpp
class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
        vector<vector<pair<int,int>>> adj(n);
        for(auto it : roads){
            adj[it[0]].push_back({it[1],it[2]}); 
            adj[it[1]].push_back({it[0],it[2]});
        }

        priority_queue<pair<long,long>,vector<pair<long,long>>,greater<pair<long,long>>> pq;
        vector<long long> dist(n,1e18) , ways(n,0); 
        dist[0] = 0;
        ways[0] = 1;
        int mod = (int)(1e9+7); 
        pq.push({0,0});

        while(!pq.empty()){
            long long dis = pq.top().first;
            int node = pq.top().second;
            pq.pop();

            if (dis > dist[node]) continue;

            for(auto it : adj[node]){
                int adjnode = it.first;
                int edjwt = it.second;

                if(dis + edjwt < dist[adjnode]){ 
                    dist[adjnode] = dis + edjwt;
                    ways[adjnode] = ways[node] % mod;
                    pq.push({dis+edjwt,adjnode});
                }
                else if(dis + edjwt == dist[adjnode]){
                    ways[adjnode] = (ways[adjnode] + ways[node]) % mod;
                }
            }
        }
        return (int)(ways[n-1] % mod); 
    }
};
```

---

## Approach

* Use **Dijkstra’s Algorithm** to compute the shortest distance from node `0` to all other nodes.
* Maintain an array `ways[]` where `ways[i]` = number of shortest paths to reach node `i`.
* While relaxing edges:

  * If a new **shorter path** is found → update `dist[]` and set `ways[next] = ways[curr]`.
  * If another path with **same shortest distance** is found → add the count:
    `ways[next] += ways[curr]`.
* At the end, `ways[n-1]` gives the number of shortest paths to the destination.

---

## Complexity

* **Time:** `O((E + V) log V)`

  * Dijkstra’s algorithm using min-heap.
* **Space:** `O(V + E)`

  * Graph adjacency list + distance + ways arrays.

---
