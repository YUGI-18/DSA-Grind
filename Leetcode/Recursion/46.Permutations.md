
# ğŸ”¢ Permutations

## ğŸ“ Problem Statement

Given an array `nums` of **distinct integers**, return **all possible permutations**.
You can return the answer in **any order**.

---

## âœ¨ Examples

### Example 1:

**Input:** `nums = [1,2,3]`
**Output:** `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`

### Example 2:

**Input:** `nums = [0,1]`
**Output:** `[[0,1],[1,0]]`

### Example 3:

**Input:** `nums = [1]`
**Output:** `[[1]]`

---

## ğŸš€ Approach

* Use **backtracking** with **swapping** technique.
* Fix one number at a time (starting from index `n`) and **swap** with every element from that index onwards.
* Recurse for the next index.
* Backtrack by **swapping back** to restore the original array.

---

## ğŸ”¢ Code Implementation

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        perms(nums, 0, ans);
        return ans;
    }

    void perms(vector<int>& nums, int n, vector<vector<int>>& ans) {
        if (n == nums.size()) {
            ans.push_back(nums);
            return;
        }

        for (int i = n; i < nums.size(); i++) {
            swap(nums[i], nums[n]);
            perms(nums, n + 1, ans);
            swap(nums[i], nums[n]); // backtrack
        }
    }
};
```

---

## â± Time Complexity

* **O(n Ã— n!)** â€” There are `n!` permutations and each takes `O(n)` time to copy.

## ğŸ’¾ Space Complexity

* **O(n)** â€” Recursion stack space.

---

## ğŸŒŸ Key Points

* Swap-based backtracking avoids extra space for visited elements.
* At each level, we fix one element and explore all possible placements for remaining elements.
* Restore the array with a swap to maintain the original state (backtrack).

---