
# 🌳 105. Construct Binary Tree from Preorder and Inorder Traversal

## 📝 Problem Statement

You are given two integer arrays:

* `preorder`: the preorder traversal of a binary tree.
* `inorder`: the inorder traversal of the same binary tree.

Your task is to **construct and return the binary tree** from these traversals.

---

## 📥 Input

* `preorder = [3,9,20,15,7]`
* `inorder = [9,3,15,20,7]`

## 📤 Output

* `[3,9,20,null,null,15,7]`

---

## ✅ Your Code (C++ — **As It Is**)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        map<int,int> mpp;
        for(int i=0 ;i < inorder.size(); i++){
            mpp[inorder[i]] = i;
        }
        TreeNode* root = buildtree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,mpp);
        return root;
    }
    TreeNode* buildtree(vector<int>& preorder,int prestart,int preend, vector<int>& inorder,int instart,int inend,map<int,int>& mpp){
        if(prestart>preend || instart>inend) return NULL;

        TreeNode* root = new TreeNode(preorder[prestart]);
        int inroot = mpp[root->val];
        int numleft = inroot - instart;

        root->left = buildtree(preorder,prestart+1,prestart+numleft,inorder,instart,inroot-1,mpp);
        root->right = buildtree(preorder,prestart+numleft+1,preend,inorder,inroot+1,inend,mpp);

        return root;
    }
};
```

---

## 🔍 Dry Run (Example 1)

### Given:

* `preorder = [3, 9, 20, 15, 7]`
* `inorder =  [9, 3, 15, 20, 7]`

### Steps:

1. First node in preorder is `3` → root.
2. In inorder, `3` splits left (`[9]`) and right (`[15,20,7]`).
3. Next root from preorder is `9` → left child of `3`.
4. Next root from preorder is `20` → right child of `3`.
5. In inorder, `20` splits to `[15]` and `[7]`.
6. `15` becomes left of `20`, `7` becomes right of `20`.

### Result:

```
        3
       / \
      9   20
         /  \
       15    7
```

✅ Output: `[3,9,20,null,null,15,7]`

---

## 💡 Approach

1. **Mapping for Fast Lookup**

   * Create a map of `inorder` values to their indices for O(1) access.

2. **Recursive Tree Building**

   * Base case: when the start > end in preorder or inorder.
   * The root is the current `preorder[prestart]`.
   * Get index of root in inorder using the map.
   * Calculate number of nodes in left subtree.
   * Recurse for left and right subtree using the ranges.

---

## ⏱️ Time and Space Complexity

* **Time Complexity:** `O(N)`

  * Each node is visited once, and map lookups are constant time.

* **Space Complexity:** `O(N)`

  * For the recursion stack and the map storing node indices.

---
