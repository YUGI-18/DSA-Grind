
# 🌳 106. Construct Binary Tree from Inorder and Postorder Traversal

## 📝 Problem Statement

You are given two integer arrays:

* `inorder`: the **inorder traversal** of a binary tree
* `postorder`: the **postorder traversal** of the same binary tree

Your task is to **construct and return the binary tree**.

---

## 📥 Input

Example 1:

* `inorder = [9,3,15,20,7]`
* `postorder = [9,15,7,20,3]`

Example 2:

* `inorder = [-1]`
* `postorder = [-1]`

## 📤 Output

Example 1:

```
      3
     / \
    9  20
      /  \
     15   7
```

* Output (TreeNode structure): `[3,9,20,null,null,15,7]`

Example 2:

* Output: `[-1]`

---

## ✅ Your Code (C++ — **As It Is**)

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        map<int,int> mpp;
        for(int i=0;i<inorder.size();i++){
            mpp[inorder[i]]=i;
        }
        return buildtree(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1,mpp);
    }

    TreeNode* buildtree(vector<int>& inorder,int instart,int inend,vector<int>& postorder,int postart,int poend,map<int,int>& mpp){
        if(instart > inend || postart > poend) return NULL;

        TreeNode* root = new TreeNode(postorder[poend]);
        int inroot = mpp[postorder[poend]];
        int numleft = inroot - instart;

        root->left = buildtree(inorder,instart,inroot-1,postorder,postart,postart+numleft-1,mpp); 
        root->right = buildtree(inorder,inroot+1,inend,postorder,postart+numleft,poend-1,mpp);

        return root;
    }
};
```

---

## 🔍 Dry Run (Example 1)

Given:

* `inorder = [9,3,15,20,7]`
* `postorder = [9,15,7,20,3]`

**Step-by-step:**

1. The last element in postorder (`3`) is the root.
2. `3` is at index `1` in inorder ⇒ left subtree has 1 element (`[9]`), right subtree has 3 elements (`[15,20,7]`).
3. Recursively build left and right using index ranges:

   * Left: inorder `[9]`, postorder `[9]`
   * Right: inorder `[15,20,7]`, postorder `[15,7,20]`

This continues recursively until the tree is built.

✅ Output: `[3,9,20,null,null,15,7]`

---

## 💡 Approach

1. **Map Inorder Indices:**

   * Create a hashmap to find the index of a value in the inorder array in `O(1)` time.

2. **Recursive Tree Construction:**

   * Use the last element of postorder as the root.
   * Find that root in inorder to split into left and right subtrees.
   * Recursively build the left and right subtrees.

3. **Base Case:**

   * If the start index exceeds the end index in either inorder or postorder, return `NULL`.

---

## ⏱️ Time and Space Complexity

* **Time Complexity:** `O(N)`

  * Each node is processed once.
  * The `map` lookup is constant time.

* **Space Complexity:** `O(N)`

  * Due to the hashmap and recursive call stack (worst case for skewed tree).

---
