
# 🔄 Flatten Binary Tree to Linked List

## Problem Statement

Given the root of a binary tree, flatten the tree into a "linked list":

* The "linked list" should use the same `TreeNode` class.
* The `right` child pointer should point to the next node in the list.
* The `left` child pointer should always be `null`.
* The flattened tree should follow the **preorder traversal** (Node → Left → Right).

---

## 🎯 Objective

Transform the binary tree into a flattened linked list in-place, without using extra space (O(1) space).

---

## ✨ Example

### Example 1:

**Input:**

```
root = [1,2,5,3,4,null,6]
```

**Output:**

```
[1,null,2,null,3,null,4,null,5,null,6]
```

### Example 2:

**Input:**

```
root = []
```

**Output:**

```
[]
```

### Example 3:

**Input:**

```
root = [0]
```

**Output:**

```
[0]
```

---

## 🚀 Approach: Reverse Preorder (Right → Left → Node)

### *Algorithm*

1. Use a helper function `flat()` with parameters: `cur` (current node), and a reference `prev` to store the previously visited node.
2. Traverse the tree in **reverse preorder**: Right → Left → Node.
3. For each node:

   * Recursively flatten the right subtree.
   * Recursively flatten the left subtree.
   * Connect current node's `right` to `prev`.
   * Set current node's `left` to `null`.
   * Update `prev` to current node.

---

### Code Implementation

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* prev = NULL;
        TreeNode* cur = root;
        flat(cur, prev);
    }
    void flat(TreeNode* cur, TreeNode* &prev) {
        if (cur == NULL) return;
        flat(cur->right, prev);
        flat(cur->left, prev);

        cur->right = prev;
        cur->left = NULL;
        prev = cur;
    }
};
```

---

## 🔍 Dry Run

### Input:

```
        1
       / \
      2   5
     / \   \
    3   4   6
```

### Traversal Order:

Right → Left → Node

1. flat(6): `prev = NULL`, so `6.right = NULL`, `prev = 6`
2. flat(5): `5.right = 6`, `prev = 5`
3. flat(4): `4.right = 5`, `prev = 4`
4. flat(3): `3.right = 4`, `prev = 3`
5. flat(2): `2.right = 3`, `prev = 2`
6. flat(1): `1.right = 2`, `prev = 1`

Final list:

```
1 -> 2 -> 3 -> 4 -> 5 -> 6
```

---

### ⏱️ Time Complexity:

* **O(n)** where `n` is the number of nodes (each node is visited once)

### 🧠 Space Complexity:

* **O(h)** for recursive stack, where `h` is the height of the tree
* Worst case: **O(n)** (skewed tree), Best case: **O(log n)** (balanced tree)

---

## 🔧 Constraints

* `0 <= Number of nodes <= 2000`
* `-100 <= Node.val <= 100`

---
